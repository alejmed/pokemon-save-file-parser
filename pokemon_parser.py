#!/usr/bin/env python3
"""
Pokemon Fire Red/Leaf Green Save File Parser

A complete parser for Generation 3 Pokemon save files based on PKHeX implementation.
Extracts Pokemon team data with all stats, moves, EVs, IVs, and more.

Author: Generated by Sisyphus (AI Agent)
Date: January 6, 2026
Version: 1.1

Usage:
    python3 pokemon_parser.py <save_file.sav>
"""

import struct
import sys
from typing import Dict, List, Optional, Tuple, Union

# ============================================================================
# CONSTANTS
# ============================================================================

SAVE_FILE_SIZE = 131072  # 128KB
SECTION_SIZE = 0x1000  # 4KB per section
SECTION_COUNT = 14  # Sections per save block
SECTION_1_ID = 1  # Section containing team data
POKEMON_SIZE = 100  # Bytes per Pokemon
MAX_TEAM_SIZE = 6  # Maximum Pokemon in team
TEAM_OFFSET = 0x38  # Offset of team data in Section 1
TEAM_SIZE_OFFSET = 0x34  # Offset of team size in Section 1

SAVE_BLOCK_OFFSETS = [0x000000, 0x00E000]  # Save A and Save B
SECTION_SIGNATURE = 0x08012025
FOOTER_ID_OFFSET = 0x0FF4
FOOTER_SIGNATURE_OFFSET = 0x0FF8

ENCRYPTED_DATA_START = 0x20
ENCRYPTED_DATA_END = 0x4F

ENCRYPT_KEY_XOR_RANGE = (0x20, 0x50, 4)

# Offsets within Pokemon data
PID_OFFSET = 0x00
OT_ID_OFFSET = 0x04
SPECIES_INTERNAL_OFFSET = 0x20
HELD_ITEM_OFFSET = 0x22
EXPERIENCE_OFFSET = 0x24
FRIENDSHIP_OFFSET = 0x29
PP_BONUSES_OFFSET = 0x28

MOVE_OFFSETS = [0x2C, 0x2E, 0x30, 0x32]  # 4 moves
PP_OFFSETS = [0x34, 0x35, 0x36, 0x37]  # PP for each move

EV_OFFSETS = {
    'hp': 0x38,
    'attack': 0x39,
    'defense': 0x3A,
    'speed': 0x3B,
    'sp_attack': 0x3C,
    'sp_defense': 0x3D
}

IV32_OFFSET = 0x48

BATTLE_STATS_OFFSETS = {
    'level': 0x54,
    'current_hp': 0x56,
    'max_hp': 0x58,
    'attack': 0x5A,
    'defense': 0x5C,
    'speed': 0x5E,
    'sp_attack': 0x60,
    'sp_defense': 0x62
}

# ============================================================================
# DATA LOOKUP TABLES
# ============================================================================

SPECIES_NAMES: Dict[int, str] = {
    0: "??????????",
    1: "Bulbasaur", 2: "Ivysaur", 3: "Venusaur",
    4: "Charmander", 5: "Charmeleon", 6: "Charizard",
    7: "Squirtle", 8: "Wartortle", 9: "Blastoise",
    25: "Pikachu", 26: "Raichu",
    94: "Gengar", 130: "Gyarados", 131: "Lapras", 143: "Snorlax",
    149: "Dragonite", 150: "Mewtwo", 151: "Mew",
    277: "Treecko", 278: "Grovyle", 279: "Sceptile",
    280: "Torchic", 281: "Combusken", 282: "Blaziken",
    283: "Mudkip", 284: "Marshtomp", 285: "Swampert",
    286: "Poochyena", 287: "Mightyena",
    376: "Absol",
    400: "Metagross",
}

MOVE_NAMES: Dict[int, str] = {
    1: "Pound", 9: "Tackle", 10: "Scratch", 14: "Cut",
    31: "Headbutt", 33: "Take Down", 34: "Double-Edge", 37: "Leer",
    43: "Peck", 45: "Low Kick", 50: "Ember", 52: "Flamethrower",
    53: "Water Gun", 55: "Hydro Pump", 57: "Bubble Beam",
    58: "Ice Beam", 59: "Blizzard", 63: "Psychic", 64: "Hypnosis",
    67: "Quick Attack", 68: "Razor Leaf", 69: "Vine Whip",
    70: "Mega Drain", 71: "Leech Seed", 73: "Solar Beam",
    74: "Poison Powder", 76: "Sleep Powder", 77: "Petal Dance",
    82: "Sludge", 83: "Sludge Bomb", 84: "Confusion", 85: "Psychic",
    89: "Earthquake", 90: "Fissure", 91: "Dig", 92: "Toxic",
    94: "Growl", 95: "Roar", 96: "Sing", 98: "Thunder Shock",
    99: "Thunderbolt", 100: "Thunder Wave", 101: "Thunder",
    102: "Rock Throw", 103: "Earthquake", 104: "Fissure",
    105: "Dig", 106: "Toxic", 107: "Confusion", 108: "Psychic",
    109: "Hypnosis", 110: "Meditate", 111: "Agility", 112: "Quick Attack",
    113: "Rage", 114: "Teleport", 115: "Night Shade", 116: "Mimic",
    117: "Screech", 118: "Double Team", 119: "Recover", 120: "Harden",
    121: "Minimize", 122: "Smoke Screen", 123: "Confuse Ray",
    124: "Withdraw", 125: "Defense Curl", 126: "Barrier",
    127: "Light Screen", 128: "Haze", 129: "Reflect",
    130: "Focus Energy", 131: "Bide", 132: "Metronome",
    133: "Mirror Move", 134: "Self-Destruct", 135: "Egg Bomb",
    136: "Lick", 137: "Smog", 138: "Sludge", 139: "Bone Club",
    140: "Fire Blast", 141: "Waterfall", 142: "Clamp", 143: "Swift",
    144: "Skull Bash", 145: "Spike Cannon", 146: "Constrict",
    147: "Amnesia", 148: "Kinesis", 149: "Soft-Boiled",
    150: "High Jump Kick", 151: "Glare",
    152: "Poison Gas", 153: "Barrage", 154: "Leech Life",
    155: "Lovely Kiss", 156: "Sky Attack", 157: "Transform",
    158: "Bubble", 159: "Dizzy Punch",
    160: "Sludge", 161: "Sludge Bomb", 162: "Curse", 163: "Psywave", 164: "Splash",
    165: "Acid Armor", 166: "Crabhammer", 167: "Explosion", 168: "Fury Swipes",
    169: "Bonemerang", 170: "Rest", 171: "Rock Slide",
    172: "Hyper Fang", 173: "Sharpen", 174: "Conversion",
    175: "Tri Attack", 176: "Super Fang", 177: "Slash",
    178: "Substitute", 179: "Struggle", 180: "Sketch", 181: "Triple Kick",
    182: "Thief", 183: "Spider Web", 184: "Mind Reader", 185: "Nightmare",
    186: "Flame Wheel", 187: "Snore", 188: "Curse", 189: "Flail",
    190: "Conversion 2", 191: "Aeroblast", 192: "Cotton Spore",
    193: "Reversal", 194: "Spite", 195: "Powder Snow", 196: "Protect",
    197: "Mach Punch", 198: "Scary Face", 199: "Faint Attack",
    200: "Sweet Kiss", 201: "Belly Drum", 202: "Sludge Bomb",
    203: "Mud Slap", 204: "Octazooka", 205: "Spikes",
    206: "Zap Cannon", 207: "Foresight", 208: "Destiny Bond",
    209: "Perish Song", 210: "Icy Wind", 211: "Detect", 212: "Bone Rush",
    213: "Lock-On", 214: "Outrage", 215: "Sandstorm", 216: "Giga Drain",
    217: "Endure", 218: "Charm", 219: "Rollout",
    220: "False Swipe", 221: "Swagger", 222: "Milk Drink", 223: "Spark",
    224: "Steel Wing", 225: "Mean Look", 226: "Attract", 227: "Sleep Talk",
    228: "Heal Bell", 229: "Return", 230: "Present", 231: "Frustration",
    232: "Safeguard", 233: "Pain Split", 234: "Sacred Fire", 235: "Secret Power",
    236: "Magnitude", 237: "Dynamic Punch", 238: "Megahorn",
    239: "Dragon Breath", 240: "Baton Pass", 241: "Encore", 242: "Pursuit",
    243: "Rapid Spin", 244: "Sweet Scent", 245: "Iron Tail", 246: "Metal Claw",
    247: "Vital Throw", 248: "Morning Sun", 249: "Synthesis",
    250: "Moonlight", 251: "Hidden Power", 252: "Cross Chop", 253: "Sunny Day",
    254: "Crunch", 255: "Mirror Coat", 256: "Psych Up",
    257: "Extreme Speed", 258: "Ancient Power", 259: "Shadow Ball",
    260: "Future Sight", 261: "Rock Smash", 262: "Whirlpool", 263: "Beat Up",
    264: "Fake Out", 265: "Uproar", 266: "Stockpile", 267: "Spit Up",
    268: "Swallow", 269: "Helping Hand", 270: "Torment", 271: "Will-O-Wisp",
    272: "Facade", 273: "Focus Punch", 274: "Smelling Salts",
    275: "Follow Me", 276: "Nature Power", 277: "Charge", 278: "Taunt",
    279: "Helping Hand", 280: "Trick", 281: "Role Play",
    282: "Wish", 283: "Assist", 284: "Ingrain", 285: "Superpower",
    286: "Magic Coat", 287: "Reflect", 288: "Haze",
    289: "Rest", 290: "Brick Break", 291: "Yawn", 292: "Knock Off",
    293: "Endeavor", 294: "Icy Wind", 295: "Detect",
    296: "Bone Rush", 297: "Lock-On", 298: "Outrage", 299: "Sandstorm",
    300: "Giga Drain", 301: "Endure", 302: "Arm Thrust", 303: "Camouflage",
    304: "Tail Glow", 305: "Luster Purge", 306: "Mist Ball", 307: "Feather Dance",
    308: "Teeter Dance", 309: "Blaze Kick", 310: "Mud Sport",
    311: "Ice Ball", 312: "Needle Arm", 313: "Slack Off",
    314: "Icicle Spear", 315: "Poison Fang",
    316: "Crush Claw", 317: "Explosion", 318: "Meteor Mash",
    319: "Astonish", 320: "Astonish",
    321: "Weather Ball", 322: "Aromatherapy", 323: "Fake Tears", 324: "Air Cutter",
    325: "Overheat", 326: "Odor Sleuth", 327: "Rock Tomb", 328: "Silver Wind",
    329: "Cosmic Power", 330: "Grass Whistle",
    331: "Tickle", 332: "Cosmic Power",
    333: "Water Spout", 334: "Signal Beam", 335: "Shadow Punch",
    336: "Extrasensory", 337: "Sky Uppercut",
    338: "Sand Tomb", 339: "Sheer Cold", 340: "Muddy Water",
    341: "Bullet Seed", 342: "Aerial Ace", 343: "Icicle Spear",
    344: "Iron Defense", 345: "Block", 346: "Howl",
    347: "Ancient Power", 348: "Armaldo",
    349: "Blastoise", 350: "Milotic",
    351: "Castform", 352: "Kecleon", 353: "Shuppet",
    354: "Banette", 355: "Duskull", 356: "Dusclops",
    357: "Tropius", 358: "Chimecho", 359: "Absol",
    360: "Wynaut", 361: "Snorunt", 362: "Glalie",
    363: "Spheal", 364: "Sealeo", 365: "Walrein",
    366: "Clamperl", 367: "Huntail", 368: "Glalie",
    376: "Absol", 377: "Shuppet", 378: "Seviper",
    379: "Zangoose", 380: "Solrock", 381: "Latias", 382: "Kyogre",
    383: "Groudon", 384: "Rayquaza", 385: "Jirachi",
    386: "Deoxys",
}

NATURES: List[str] = [
    "Hardy", "Lonely", "Brave", "Adamant", "Naughty",
    "Bold", "Docile", "Relaxed", "Impish", "Lax",
    "Timid", "Hasty", "Serious", "Jolly", "Naive",
    "Modest", "Mild", "Quiet", "Bashful", "Rash",
    "Calm", "Gentle", "Sassy", "Careful", "Quirky"
]

BLOCK_ORDER: List[List[int]] = [
    [0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 3, 1], [0, 3, 1, 2],
    [0, 2, 3, 1], [0, 3, 1, 2], [0, 3, 2, 1],
    [1, 2, 3, 0], [1, 2, 3, 0], [1, 2, 3, 2],
    [2, 0, 1, 3], [1, 2, 0, 3], [1, 2, 0, 2],
    [3, 0, 1, 2], [1, 2, 0, 3], [1, 2, 0, 2],
    [2, 3, 0, 1], [2, 3, 0, 1], [2, 3, 0, 1],
    [2, 3, 1, 0], [2, 3, 0, 1],
    [3, 2, 1, 0], [2, 3, 0, 1], [2, 3, 0, 1],
    [3, 1, 2, 0], [3, 1, 0, 1], [2, 3, 0, 2]
]

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def read_u8(data: Union[bytes, bytearray], offset: int) -> int:
    """Read unsigned 8-bit value at offset."""
    return data[offset]

def read_u16(data: Union[bytes, bytearray], offset: int) -> int:
    """Read unsigned 16-bit little-endian value at offset."""
    return struct.unpack('<H', data[offset:offset+2])[0]

def read_u32(data: Union[bytes, bytearray], offset: int) -> int:
    """Read unsigned 32-bit little-endian value at offset."""
    return struct.unpack('<I', data[offset:offset+4])[0]

def get_species_name(species_id: int) -> str:
    """Get Pokemon species name from internal ID."""
    return SPECIES_NAMES.get(species_id, f"Unknown #{species_id}")

def get_move_name(move_id: int) -> str:
    """Get move name from move ID."""
    return MOVE_NAMES.get(move_id, f"Move #{move_id}")

def get_nature(personality: int) -> str:
    """Get Pokemon nature from personality value."""
    return NATURES[personality % 25]

# ============================================================================
# CRYPTOGRAPHY FUNCTIONS
# ============================================================================

def decrypt_array3(data: bytearray) -> bytes:
    """Decrypt Generation 3 Pokemon encrypted data.

    Based on PKHeX implementation. XOR decrypts bytes 0x20-0x4F using
    seed derived from PID ^ OT ID, then unshuffles 4 data blocks.

    Args:
        data: 100-byte Pokemon data structure
    Returns:
        Decrypted data with blocks in correct order
    """
    if len(data) < POKEMON_SIZE:
        return bytes(data)

    data = bytearray(data)

    # Extract decryption key
    pid = read_u32(data, PID_OFFSET)
    ot_id = read_u32(data, OT_ID_OFFSET)
    seed = pid ^ ot_id

    # XOR decryption of encrypted data (bytes 0x20-0x4F)
    for i in range(ENCRYPTED_DATA_START, ENCRYPTED_DATA_END, 4):
        if i + 4 <= len(data):
            encrypted_word = read_u32(data, i)
            decrypted_word = encrypted_word ^ seed
            write_u32(data, i, decrypted_word)

    # Unshuffle blocks based on PID
    shuffle_order = BLOCK_ORDER[pid % 24]
    encrypted_blocks = [
        data[ENCRYPTED_DATA_START:ENCRYPTED_DATA_START+12],
        data[ENCRYPTED_DATA_START+12:ENCRYPTED_DATA_START+24],
        data[ENCRYPTED_DATA_START+12:ENCRYPTED_DATA_START+36],
        data[ENCRYPTED_DATA_START+12:ENCRYPTED_DATA_START+48]
    ]

    unshuffled_blocks = [bytearray(12) for _ in range(4)]
    for i, block_idx in enumerate(shuffle_order):
        unshuffled_blocks[i] = encrypted_blocks[block_idx]

    # Reconstruct data with unshuffled blocks
    data[ENCRYPTED_DATA_START:ENCRYPTED_DATA_START+12] = unshuffled_blocks[0]
    data[ENCRYPTED_DATA_START+12:ENCRYPTED_DATA_START+24] = unshuffled_blocks[1]
    data[ENCRYPTED_DATA_START+12:ENCRYPTED_DATA_START+36] = unshuffled_blocks[2]
    data[ENCRYPTED_DATA_START+12:ENCRYPTED_DATA_START+48] = unshuffled_blocks[3]

    return bytes(data)

# ============================================================================
# POKEMON DATA EXTRACTION
# ============================================================================

def extract_ivs(iv32: int) -> Dict[str, int]:
    """Extract individual values from packed 32-bit IV integer.

    IVs are stored as:
    - HP: bits 0-4
    - Attack: bits 5-9
    - Defense: bits 10-14
    - Speed: bits 15-19
    - Sp. Attack: bits 20-24
    - Sp. Defense: bits 25-29
    - Ability bit: bit 31

    Args:
        iv32: Packed 32-bit integer containing all IVs

    Returns:
        Dictionary with HP, Attack, Defense, Speed, Sp. Attack,
        Sp. Defense IVs (0-31) and ability bit (0-1)
    """
    return {
        'hp': (iv32 >> 0) & 0x1F,
        'attack': (iv32 >> 5) & 0x1F,
        'defense': (iv32 >> 10) & 0x1F,
        'speed': (iv32 >> 15) & 0x1F,
        'sp_attack': (iv32 >> 20) & 0x1F,
        'sp_defense': (iv32 >> 25) & 0x1F,
        'ability_bit': (iv32 >> 31) & 0x1
    }

def parse_pokemon(pokemon_data: bytes) -> Optional[Dict]:
    """Parse a single Pokemon from 100-byte data structure.

    Extracts all Pokemon information including stats, moves, EVs, IVs,
    and other attributes using PKHeX-based parsing logic.

    Args:
        pokemon_data: 100-byte raw Pokemon data structure

    Returns:
        Dictionary containing all Pokemon data, or None if invalid data
    """
    if len(pokemon_data) < POKEMON_SIZE:
        return None

    # Decrypt encrypted data section
    decrypted_data = decrypt_array3(bytearray(pokemon_data))

    # Basic unencrypted data
    pid = read_u32(decrypted_data, PID_OFFSET)
    ot_id = read_u32(decrypted_data, OT_ID_OFFSET)

    # Species and growth info (from encrypted data)
    species_internal = read_u16(decrypted_data, SPECIES_INTERNAL_OFFSET)
    held_item = read_u16(decrypted_data, HELD_ITEM_OFFSET)
    experience = read_u32(decrypted_data, EXPERIENCE_OFFSET)
    friendship = read_u8(decrypted_data, FRIENDSHIP_OFFSET)
    pp_bonuses = read_u8(decrypted_data, PP_BONUSES_OFFSET)

    # Extract moves
    moves = []
    for i in range(4):
        move_id = read_u16(decrypted_data, MOVE_OFFSETS[i])
        moves.append({
            'id': move_id,
            'name': get_move_name(move_id)
        })

    # Extract EVs (Effort Values)
    evs = {
        stat: read_u8(decrypted_data, offset)
        for stat, offset in EV_OFFSETS.items()
    }

    # Extract IVs (Individual Values)
    iv32 = read_u32(decrypted_data, IV32_OFFSET)
    ivs = extract_ivs(iv32)

    # Battle stats (unencrypted)
    level = read_u8(decrypted_data, BATTLE_STATS_OFFSETS['level'])
    current_hp = read_u16(decrypted_data, BATTLE_STATS_OFFSETS['current_hp'])
    max_hp = read_u16(decrypted_data, BATTLE_STATS_OFFSETS['max_hp'])
    attack = read_u16(decrypted_data, BATTLE_STATS_OFFSETS['attack'])
    defense = read_u16(decrypted_data, BATTLE_STATS_OFFSETS['defense'])
    speed = read_u16(decrypted_data, BATTLE_STATS_OFFSETS['speed'])
    sp_attack = read_u16(decrypted_data, BATTLE_STATS_OFFSETS['sp_attack'])
    sp_defense = read_u16(decrypted_data, BATTLE_STATS_OFFSETS['sp_defense'])

    return {
        'species_id': species_internal,
        'species_name': get_species_name(species_internal),
        'level': level,
        'current_hp': current_hp,
        'max_hp': max_hp,
        'attack': attack,
        'defense': defense,
        'speed': speed,
        'sp_attack': sp_attack,
        'sp_defense': sp_defense,
        'pid': pid,
        'ot_id': ot_id & 0xFFFF,
        'moves': moves,
        'evs': evs,
        'ivs': ivs,
        'friendship': friendship,
        'held_item': held_item,
        'experience': experience,
        'nature': get_nature(pid)
    }

# ============================================================================
# SAVE FILE NAVIGATION
# ============================================================================

def find_section(save_data: bytes, section_id: int) -> Optional[bytes]:
    """Find a section by ID in Pokemon save file.

    Searches both save blocks (A and B) for specified section ID,
    verifying the section signature to ensure validity.

    Args:
        save_data: Complete 128KB save file data
        section_id: Section ID to find (0-13)

    Returns:
        4KB section data if found, None otherwise
    """
    for save_block_offset in SAVE_BLOCK_OFFSETS:
        for section_idx in range(SECTION_COUNT):
            section_offset = save_block_offset + (section_idx * SECTION_SIZE)
            footer_id = read_u16(save_data, section_offset + FOOTER_ID_OFFSET)

            if footer_id == section_id:
                signature = read_u32(save_data, section_offset + FOOTER_SIGNATURE_OFFSET)
                if signature == SECTION_SIGNATURE:
                    return save_data[section_offset:section_offset + SECTION_SIZE]

    return None

# ============================================================================
# DISPLAY FUNCTIONS
# ============================================================================

def format_iv_comment(iv_value: int) -> str:
    """Add comment to IV value based on quality."""
    if iv_value >= 31:
        return "Perfect!"
    elif iv_value >= 25:
        return "Excellent!"
    elif iv_value >= 20:
        return "Great!"
    elif iv_value >= 15:
        return "Good"
    elif iv_value >= 10:
        return "Average"
    else:
        return "Poor"

def display_pokemon(pokemon: Dict, index: int) -> None:
    """Display complete Pokemon information.

    Args:
        pokemon: Dictionary containing all Pokemon data
        index: Pokemon number in team (1-based)

    """
    separator = "=" * 70
    print(f"\n{separator}")
    print(f"POKEMON {index}: {pokemon['species_name'].upper()}")
    print(f"{separator}")

    print(f"\nBasic Info:")
    print(f"  Species ID: {pokemon['species_id']}")
    print(f"  Level: {pokemon['level']}")
    print(f"  Nature: {pokemon['nature']}")
    print(f"  Experience: {pokemon['experience']:,}")
    print(f"  Friendship: {pokemon['friendship']}")
    print(f"  Held Item: {pokemon['held_item']}")
    print(f"  Personality Value (PID): 0x{pokemon['pid']:08X}")
    print(f"  Original Trainer ID: {pokemon['ot_id']}")

    print(f"\nBattle Stats:")
    print(f"  HP: {pokemon['current_hp']}/{pokemon['max_hp']}")
    print(f"  Attack: {pokemon['attack']}")
    print(f"  Defense: {pokemon['defense']}")
    print(f"  Speed: {pokemon['speed']}")
    print(f"  Special Attack: {pokemon['sp_attack']}")
    print(f"  Special Defense: {pokemon['sp_defense']}")

    print(f"\nMoves:")
    for i, move in enumerate(pokemon['moves'], 1):
        if move['id'] != 0:
            print(f"  {i}. {move['name']} (ID: {move['id']})")

    print(f"\nEVs (Effort Values):")
    ev_labels = {
        'hp': 'HP', 'attack': 'Attack', 'defense': 'Defense',
        'speed': 'Speed', 'sp_attack': 'Sp. Attack', 'sp_defense': 'Sp. Defense'
    }
    for stat, label in ev_labels.items():
        print(f"  {label}: {pokemon['evs'][stat]}")

    print(f"\nIVs (Individual Values):")
    iv_labels = ev_labels
    for stat, label in iv_labels.items():
        iv_value = pokemon['ivs'][stat]
        comment = format_iv_comment(iv_value)
        print(f"  {label}: {iv_value} ({comment})")

    print(f"\nOther:")
    print(f"  Nature: {pokemon['nature']}")
    print(f"  Experience: {pokemon['experience']}")
    print(f"  Friendship: {pokemon['friendship']}")
    print(f"  Held Item: {pokemon['held_item']}")
    print(f"  Species ID: {pokemon['species_id']}")
    print(f"  PID: 0x{pokemon['pid']:08X}")
    print(f"  OT ID: {pokemon['ot_id']}")

# ============================================================================
# MAIN FUNCTION
# ============================================================================

def main() -> None:
    """Main entry point for Pokemon save file parser."""
    if len(sys.argv) != 2:
        print("Usage: python3 pokemon_parser.py <save_file.sav>")
        sys.exit(1)

    save_file = sys.argv[1]

    try:
        with open(save_file, 'rb') as f:
            save_data = f.read()
    except FileNotFoundError:
        print(f"Error: File '{save_file}' not found")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading save file: {e}")
        sys.exit(1)

    if len(save_data) != SAVE_FILE_SIZE:
        print(f"Warning: Save file size is {len(save_data)} bytes, "
              f"expected {SAVE_FILE_SIZE} bytes")

    # Find Section 1 (contains team data)
    section_1 = find_section(save_data, SECTION_1_ID)
    if not section_1:
        print("Error: Could not find Section 1 in save file")
        sys.exit(1)

    # Get team size and parse Pokemon
    team_size = read_u8(section_1, TEAM_SIZE_OFFSET)
    print(f"Team size: {team_size}\n")

    team = []
    for i in range(min(team_size, MAX_TEAM_SIZE)):
        offset = TEAM_OFFSET + (i * POKEMON_SIZE)
        pokemon_data = section_1[offset:offset+POKEMON_SIZE]
        pokemon = parse_pokemon(pokemon_data)
        if pokemon:
            team.append(pokemon)

    # Display all Pokemon
    print("=" * 70)
    print("POKEMON TEAM - Complete Details")
    print("=" * 70)

    for i, pokemon in enumerate(team, 1):
        display_pokemon(pokemon, i)

    print(f"\n{'=' * 70}\n")

if __name__ == "__main__":
    main()